#
# madwifi-0.9.2 true_radiotap_parser.diff
#
# This patch adds radiotap header parsing capability to ieee80211_monitor_encap.
# It allows userspace applications to send frames encapsulated in radiotap
# header containing any arbitrary subset of fields (from the set of known ones)
# instead of the fixed ath_tx_radiotap_header. It properly handles extended
# field presence bitmaps and removes FCS from the end of the frame if it is
# present according to an apropriate radiotap header flag. Parsing stops after
# encountering unknown field.
#
# 2006-09-18, Michal Wrobel <xmxwx@asn.pl>
#
--- madwifi/net80211/ieee80211_monitor.c
+++ madwifi/net80211/ieee80211_monitor.c
@@ -165,6 +163,107 @@
 			ph->try0 = 1;
                 break;
 	}
+	case ARPHRD_IEEE80211_RADIOTAP: {
+		struct ieee80211_frame *wh = NULL;
+		struct ieee80211_radiotap_header *rh =
+			(struct ieee80211_radiotap_header *)skb->data;
+		u_int32_t present, present_ext;
+		u_int16_t len;
+		u_int8_t *start = skb->data + sizeof(struct ieee80211_radiotap_header);
+		u_int8_t *p = start;
+		u_int8_t *end = skb->data + skb->len;
+		u_int8_t bit, flags = 0;
+
+		if (skb->len < sizeof(*rh) || rh->it_version != 0)
+			break;
+
+		present_ext = present = le32_to_cpu(rh->it_present);
+		len = le16_to_cpu(rh->it_len);
+
+		if (skb->len < len)
+			break;
+
+		/* skip the chain of additional bitmaps following it_present */
+		while (present_ext & (1 << IEEE80211_RADIOTAP_EXT)) {
+			if (p+4 > end) {
+				/* An extended bitmap would now follow, but there is 
+				 * no place for it. Stop parsing. */
+				present = 0;
+				break;
+			}
+			present_ext = le32_to_cpu(*(u_int32_t*)p);
+			p += 4;
+		}
+
+		for (bit = 0; present && p < end; present >>= 1, bit++) {
+			if ((present & 1) == 0)
+				continue;
+			switch (bit) {
+				case IEEE80211_RADIOTAP_RATE:
+					ph->rate0 = *p;
+					p++;
+					break;
+
+				case IEEE80211_RADIOTAP_DBM_TX_POWER:
+					ph->power = *p;
+					p++;
+					break;
+
+				case IEEE80211_RADIOTAP_FLAGS:
+					flags = *p;
+					p++;
+					break;
+
+				case IEEE80211_RADIOTAP_DB_ANTSIGNAL:
+				case IEEE80211_RADIOTAP_DB_ANTNOISE:
+				case IEEE80211_RADIOTAP_ANTENNA:
+				case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:
+				case IEEE80211_RADIOTAP_DBM_ANTNOISE:
+					/* 8-bit */
+					p++;
+					break;
+
+				case IEEE80211_RADIOTAP_FHSS:
+					/* 2 x 8-bit */
+					p += 2;
+					break;
+
+				case IEEE80211_RADIOTAP_LOCK_QUALITY:
+				case IEEE80211_RADIOTAP_TX_ATTENUATION:
+				case IEEE80211_RADIOTAP_DB_TX_ATTENUATION:
+					/* 16-bit */
+					p = start + roundup(p - start, 2) + 2;
+					break;
+
+				case IEEE80211_RADIOTAP_CHANNEL:
+					/* 2 x 16-bit */
+					p = start + roundup(p - start, 2) + 4;
+					break;
+
+				case IEEE80211_RADIOTAP_FCS:
+					/* 32-bit */
+					p = start + roundup(p - start, 4) + 4;
+					break;
+
+				case IEEE80211_RADIOTAP_TSFT:
+					/* 64-bit */
+					p = start + roundup(p - start, 8) + 8;
+					break;
+
+				default:
+					present = 0;
+					break;
+			}
+		}
+		skb_pull(skb, len);
+		if (flags & IEEE80211_RADIOTAP_F_FCS)
+			/* Remove FCS from the end of frames to transmit */
+			skb_trim(skb, skb->len - IEEE80211_CRC_LEN);
+		wh = (struct ieee80211_frame *)skb->data;
+		if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) 
+			ph->try0 = 1;
+                break;
+	}
 	case ARPHRD_IEEE80211_ATHDESC: {
 		if (skb->len > ATHDESC_HEADER_SIZE) {
 			struct ar5212_openbsd_desc *desc =
@@ -182,16 +281,6 @@
 		}
 		break;
 	}	
-	case ARPHRD_IEEE80211_RADIOTAP: {
-		if(skb->len >  sizeof(struct ath_tx_radiotap_header)) {
-			struct ath_tx_radiotap_header *wh = (struct ath_tx_radiotap_header *) skb->data;
-			ph->power = wh->wt_txpower;
-			ph->rate0 = wh->wt_rate;
-			ph->try0 = 1;
-			skb_pull(skb, sizeof(struct ath_tx_radiotap_header));
-		}
-		break;
-	}
 	default:
 		break;
 	}
--- madwifi/net80211/ieee80211_radiotap.h
+++ madwifi/net80211/ieee80211_radiotap.h
@@ -216,5 +216,11 @@
 #define	IEEE80211_RADIOTAP_F_FRAG	0x08	/* sent/received
 						 * with fragmentation
 						 */
+#define	IEEE80211_RADIOTAP_F_FCS	0x10	/* frame includes FCS */
+#define	IEEE80211_RADIOTAP_F_DATAPAD	0x20	/* frame has padding between
+						 * 802.11 header and payload
+						 * (to 32-bit boundary)
+						 */
+#define	IEEE80211_RADIOTAP_F_BADFCS	0x40	/* does not pass FCS check */
 
 #endif /* _NET_IF_IEEE80211RADIOTAP_H_ */
